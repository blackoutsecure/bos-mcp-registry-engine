const path = require('path');
const { expect } = require('chai');
const fs = require('fs-extra');
const { runRegistryGeneration } = require('../src/lib/registry-generator');
const { createLogger } = require('../src/lib/logger');
const {
  cleanupWorkspace,
  createTempWorkspace,
  resolveOutputPath,
} = require('./test-helpers');

async function listFilesRecursively(rootDir) {
  const entries = await fs.readdir(rootDir);
  const files = [];

  for (const entry of entries) {
    const entryPath = path.join(rootDir, entry);
    const stats = await fs.stat(entryPath);
    if (stats.isDirectory()) {
      files.push(...(await listFilesRecursively(entryPath)));
      continue;
    }

    files.push(entryPath);
  }

  return files;
}

describe('registry-generator', () => {
  let workspaceRoot;
  const encodedServerName = encodeURIComponent('io.github.github/github');

  beforeEach(async () => {
    workspaceRoot = await createTempWorkspace();
  });

  afterEach(async () => {
    await cleanupWorkspace(workspaceRoot);
  });

  it('validates server manifests in validate-only mode', async () => {
    const result = await runRegistryGeneration({
      workspaceRoot,
      actionType: 'validate_registry',
      sourceDir: './servers',
      outputDir: './dist',
      deploymentEnvironment: 'github',
      schemasDir: path.join(workspaceRoot, 'schemas'),
    });

    expect(result.validated).to.equal(true);
    expect(result.serverCount).to.equal(1);
  });

  it('generates required static registry files', async () => {
    await runRegistryGeneration({
      workspaceRoot,
      sourceDir: './servers',
      outputDir: './dist',
      deploymentEnvironment: 'github',
      schemasDir: path.join(workspaceRoot, 'schemas'),
    });

    const outputRoot = resolveOutputPath(workspaceRoot);
    const versionRoot = path.join(outputRoot, 'v0.1');

    expect(await fs.pathExists(path.join(outputRoot, 'index.html'))).to.equal(
      true,
    );
    expect(await fs.pathExists(path.join(versionRoot, 'index.html'))).to.equal(
      true,
    );
    expect(
      await fs.pathExists(path.join(versionRoot, 'servers.json')),
    ).to.equal(true);
    expect(
      await fs.pathExists(path.join(versionRoot, 'servers', 'index.json')),
    ).to.equal(true);
    expect(
      await fs.pathExists(
        path.join(
          versionRoot,
          'servers',
          encodedServerName,
          'versions',
          '1.0.0.json',
        ),
      ),
    ).to.equal(true);
    expect(
      await fs.pathExists(
        path.join(
          versionRoot,
          'servers',
          encodedServerName,
          'versions',
          '1.0.0',
        ),
      ),
    ).to.equal(true);
    expect(
      await fs.pathExists(
        path.join(
          versionRoot,
          'servers',
          encodedServerName,
          'versions',
          'latest.json',
        ),
      ),
    ).to.equal(true);
    expect(
      await fs.pathExists(
        path.join(
          versionRoot,
          'servers',
          encodedServerName,
          'versions',
          'latest',
        ),
      ),
    ).to.equal(true);
    expect(
      await fs.pathExists(
        path.join(versionRoot, 'servers', encodedServerName, 'versions.json'),
      ),
    ).to.equal(true);
    expect(
      await fs.pathExists(
        path.join(
          versionRoot,
          'servers',
          encodedServerName,
          'versions',
          'index.json',
        ),
      ),
    ).to.equal(true);

    const serversList = await fs.readJson(
      path.join(versionRoot, 'servers', 'index.json'),
    );
    const rootIndexHtml = await fs.readFile(
      path.join(outputRoot, 'index.html'),
      'utf8',
    );
    const versionIndexHtml = await fs.readFile(
      path.join(versionRoot, 'index.html'),
      'utf8',
    );

    expect(rootIndexHtml).to.contain('Generated by Blackout Secure MCP Registry Engine.');
    expect(rootIndexHtml).to.contain('Maintained by');
    expect(rootIndexHtml).to.contain('https://blackoutsecure.app');
    expect(rootIndexHtml).to.contain('Generated file metadata');
    expect(rootIndexHtml).to.contain('Metadata standard: oss-v1');

    expect(versionIndexHtml).to.contain('Generated by Blackout Secure MCP Registry Engine.');
    expect(versionIndexHtml).to.contain('Maintained by');
    expect(versionIndexHtml).to.contain('https://blackoutsecure.app');
    expect(versionIndexHtml).to.contain('Generated file metadata');
    expect(versionIndexHtml).to.contain('Metadata standard: oss-v1');

    expect(serversList.servers).to.be.an('array');
    expect(serversList.servers[0]).to.have.property('server');
    expect(serversList.servers[0]).to.have.property('_meta');
  });

  it('generates cloudflare files when enabled', async () => {
    await runRegistryGeneration({
      workspaceRoot,
      sourceDir: './servers',
      outputDir: './dist',
      deploymentEnvironment: 'cloudflare',
      schemasDir: path.join(workspaceRoot, 'schemas'),
    });

    const outputRoot = resolveOutputPath(workspaceRoot);

    expect(await fs.pathExists(path.join(outputRoot, '_headers'))).to.equal(
      true,
    );
    expect(await fs.pathExists(path.join(outputRoot, '_redirects'))).to.equal(
      true,
    );

    const headers = await fs.readFile(path.join(outputRoot, '_headers'), 'utf8');
    expect(headers).to.contain('X-Robots-Tag: noindex, nofollow');
    expect(headers).to.contain("script-src-elem 'self' https://static.cloudflareinsights.com");
    expect(headers).to.contain("connect-src 'self' https://cloudflareinsights.com");
    expect(headers).to.contain('Access-Control-Expose-Headers: ETag, Last-Modified, Cache-Control, Content-Length, Content-Type');
    expect(headers).to.contain('Access-Control-Max-Age: 86400');
  });

  it('logs cloudflare profile file contents in debug mode', async () => {
    const originalConsoleLog = console.log;
    const capturedLogs = [];

    console.log = (...args) => {
      capturedLogs.push(args.join(' '));
    };

    try {
      await runRegistryGeneration({
        workspaceRoot,
        sourceDir: './servers',
        outputDir: './dist',
        deploymentEnvironment: 'cloudflare',
        schemasDir: path.join(workspaceRoot, 'schemas'),
        logger: createLogger('debug'),
      });
    } finally {
      console.log = originalConsoleLog;
    }

    const debugOutput = capturedLogs.join('\n');
    expect(debugOutput).to.contain('[DEBUG] _headers');
    expect(debugOutput).to.contain('X-Robots-Tag: noindex, nofollow');
    expect(debugOutput).to.contain('[DEBUG] _redirects');
    expect(debugOutput).to.contain('/v0.1/health /v0.1/health.json 302');
  });

  it('defaults to lean cloudflare output when not explicitly configured', async () => {
    await runRegistryGeneration({
      workspaceRoot,
      sourceDir: './servers',
      outputDir: './dist',
      deploymentEnvironment: 'cloudflare',
      schemasDir: path.join(workspaceRoot, 'schemas'),
    });

    const outputRoot = resolveOutputPath(workspaceRoot);
    const versionRoot = path.join(outputRoot, 'v0.1');

    expect(await fs.pathExists(path.join(versionRoot, 'health.json'))).to.equal(
      true,
    );
    expect(await fs.pathExists(path.join(versionRoot, 'health'))).to.equal(
      false,
    );
  });

  it('generates lean cloudflare output when enabled', async () => {
    await runRegistryGeneration({
      workspaceRoot,
      sourceDir: './servers',
      outputDir: './dist',
      deploymentEnvironment: 'cloudflare',
      cloudflareLeanOutput: true,
      schemasDir: path.join(workspaceRoot, 'schemas'),
    });

    const outputRoot = resolveOutputPath(workspaceRoot);
    const versionRoot = path.join(outputRoot, 'v0.1');

    expect(await fs.pathExists(path.join(versionRoot, 'health.json'))).to.equal(
      true,
    );
    expect(await fs.pathExists(path.join(versionRoot, 'health'))).to.equal(
      false,
    );

    expect(await fs.pathExists(path.join(versionRoot, 'ping.json'))).to.equal(
      true,
    );
    expect(await fs.pathExists(path.join(versionRoot, 'ping'))).to.equal(false);

    expect(await fs.pathExists(path.join(versionRoot, 'version.json'))).to.equal(
      true,
    );
    expect(await fs.pathExists(path.join(versionRoot, 'version'))).to.equal(
      false,
    );

    expect(
      await fs.pathExists(
        path.join(
          versionRoot,
          'servers',
          encodedServerName,
          'versions',
          '1.0.0.json',
        ),
      ),
    ).to.equal(true);
    expect(
      await fs.pathExists(
        path.join(versionRoot, 'servers', encodedServerName, 'versions', '1.0.0'),
      ),
    ).to.equal(false);

    expect(
      await fs.pathExists(
        path.join(
          versionRoot,
          'servers',
          encodedServerName,
          'versions',
          'latest.json',
        ),
      ),
    ).to.equal(true);
    expect(
      await fs.pathExists(
        path.join(versionRoot, 'servers', encodedServerName, 'versions', 'latest'),
      ),
    ).to.equal(false);

    const redirects = await fs.readFile(path.join(outputRoot, '_redirects'), 'utf8');
    expect(redirects).to.contain('/v0.1/health /v0.1/health.json 302');
    expect(redirects).to.contain('/v0.1/ping /v0.1/ping.json 302');
    expect(redirects).to.contain('/v0.1/version /v0.1/version.json 302');
    expect(redirects).to.contain(
      `/v0.1/servers/${encodedServerName}/versions/latest /v0.1/servers/${encodedServerName}/versions/latest.json 302`,
    );
    expect(redirects).to.contain(
      `/v0.1/servers/${encodedServerName}/versions/1.0.0 /v0.1/servers/${encodedServerName}/versions/1.0.0.json 302`,
    );
  });

  it('removes cloudflare files when disabled', async () => {
    const outputRoot = resolveOutputPath(workspaceRoot);
    await fs.ensureDir(outputRoot);
    await fs.writeFile(path.join(outputRoot, '_headers'), 'legacy', 'utf8');
    await fs.writeFile(path.join(outputRoot, '_redirects'), 'legacy', 'utf8');

    await runRegistryGeneration({
      workspaceRoot,
      sourceDir: './servers',
      outputDir: './dist',
      deploymentEnvironment: 'github',
      schemasDir: path.join(workspaceRoot, 'schemas'),
    });

    expect(await fs.pathExists(path.join(outputRoot, '_headers'))).to.equal(
      false,
    );
    expect(await fs.pathExists(path.join(outputRoot, '_redirects'))).to.equal(
      false,
    );
    expect(await fs.pathExists(path.join(outputRoot, '.nojekyll'))).to.equal(
      true,
    );
  });

  it('generates host-agnostic output for none profile', async () => {
    const outputRoot = resolveOutputPath(workspaceRoot);
    await fs.ensureDir(outputRoot);
    await fs.writeFile(path.join(outputRoot, '_headers'), 'legacy', 'utf8');
    await fs.writeFile(path.join(outputRoot, '_redirects'), 'legacy', 'utf8');
    await fs.writeFile(path.join(outputRoot, '.nojekyll'), 'legacy', 'utf8');

    await runRegistryGeneration({
      workspaceRoot,
      sourceDir: './servers',
      outputDir: './dist',
      deploymentEnvironment: 'none',
      schemasDir: path.join(workspaceRoot, 'schemas'),
    });

    expect(await fs.pathExists(path.join(outputRoot, '_headers'))).to.equal(
      false,
    );
    expect(await fs.pathExists(path.join(outputRoot, '_redirects'))).to.equal(
      false,
    );
    expect(await fs.pathExists(path.join(outputRoot, '.nojekyll'))).to.equal(
      false,
    );
    expect(await fs.pathExists(path.join(outputRoot, 'index.html'))).to.equal(
      true,
    );
  });

  it('cleans output root before generation so output is authoritative', async () => {
    const outputRoot = resolveOutputPath(workspaceRoot);
    await fs.ensureDir(path.join(outputRoot, 'v0.1', 'servers', 'legacy'));
    await fs.writeFile(path.join(outputRoot, 'stale.txt'), 'legacy', 'utf8');
    await fs.writeFile(
      path.join(outputRoot, 'v0.1', 'servers', 'legacy', 'old.json'),
      '{"legacy":true}',
      'utf8',
    );

    await runRegistryGeneration({
      workspaceRoot,
      sourceDir: './servers',
      outputDir: './dist',
      deploymentEnvironment: 'github',
      schemasDir: path.join(workspaceRoot, 'schemas'),
    });

    expect(await fs.pathExists(path.join(outputRoot, 'stale.txt'))).to.equal(
      false,
    );
    expect(
      await fs.pathExists(
        path.join(outputRoot, 'v0.1', 'servers', 'legacy', 'old.json'),
      ),
    ).to.equal(false);
    expect(await fs.pathExists(path.join(outputRoot, 'index.html'))).to.equal(
      true,
    );
  });

  it('supports custom config path from MCP_REGISTRY_CONFIG', async () => {
    const extraServersDir = path.join(workspaceRoot, 'extra-servers');
    await fs.copy(path.join(workspaceRoot, 'servers'), extraServersDir);

    const customConfigPath = path.join(
      workspaceRoot,
      'config',
      'custom-config.json',
    );
    await fs.ensureDir(path.dirname(customConfigPath));
    await fs.writeJson(
      customConfigPath,
      {
        version: '0.1',
        externalRepositories: ['./extra-servers'],
      },
      { spaces: 2 },
    );

    const previousConfigPath = process.env.MCP_REGISTRY_CONFIG;
    process.env.MCP_REGISTRY_CONFIG = './config/custom-config.json';

    try {
      const result = await runRegistryGeneration({
        workspaceRoot,
        actionType: 'validate_registry',
        sourceDir: './servers',
        outputDir: './dist',
        deploymentEnvironment: 'github',
        schemasDir: path.join(workspaceRoot, 'schemas'),
      });

      expect(result.validated).to.equal(true);
      expect(result.serverCount).to.equal(1);
    } finally {
      if (previousConfigPath === undefined) {
        delete process.env.MCP_REGISTRY_CONFIG;
      } else {
        process.env.MCP_REGISTRY_CONFIG = previousConfigPath;
      }
    }
  });

  it('generates an empty registry when source has no valid servers', async () => {
    const emptyServersDir = path.join(workspaceRoot, 'empty-servers');
    await fs.ensureDir(emptyServersDir);

    await runRegistryGeneration({
      workspaceRoot,
      actionType: 'generate_registry',
      sourceDir: './empty-servers',
      outputDir: './dist',
      deploymentEnvironment: 'github',
      schemasDir: path.join(workspaceRoot, 'schemas'),
    });

    const outputRoot = resolveOutputPath(workspaceRoot);
    const serversJsonPath = path.join(outputRoot, 'v0.1', 'servers.json');
    expect(await fs.pathExists(serversJsonPath)).to.equal(true);

    const serversJson = await fs.readJson(serversJsonPath);
    expect(serversJson.servers).to.be.an('array').with.length(0);
  });

  it('creates missing source directory and generates empty registry', async () => {
    const missingServersDir = path.join(workspaceRoot, 'missing-servers');

    await runRegistryGeneration({
      workspaceRoot,
      actionType: 'generate_registry',
      sourceDir: './missing-servers',
      outputDir: './dist',
      deploymentEnvironment: 'github',
      schemasDir: path.join(workspaceRoot, 'schemas'),
    });

    expect(await fs.pathExists(missingServersDir)).to.equal(true);

    const outputRoot = resolveOutputPath(workspaceRoot);
    const serversJsonPath = path.join(outputRoot, 'v0.1', 'servers.json');
    expect(await fs.pathExists(serversJsonPath)).to.equal(true);

    const serversJson = await fs.readJson(serversJsonPath);
    expect(serversJson.servers).to.be.an('array').with.length(0);
  });

  it('fails validation when source has no valid servers', async () => {
    const emptyServersDir = path.join(workspaceRoot, 'empty-servers');
    await fs.ensureDir(emptyServersDir);

    let thrownError;
    try {
      await runRegistryGeneration({
        workspaceRoot,
        actionType: 'validate_registry',
        sourceDir: './empty-servers',
        outputDir: './dist',
        deploymentEnvironment: 'github',
        schemasDir: path.join(workspaceRoot, 'schemas'),
      });
    } catch (error) {
      thrownError = error;
    }

    expect(thrownError).to.be.instanceOf(Error);
    expect(thrownError.message).to.equal('No valid servers found');
  });

  it('rejects legacy remotes.transportType in validate mode', async () => {
    const versionPath = path.join(
      workspaceRoot,
      'servers',
      'github',
      'versions',
      '1.0.0.json',
    );

    await fs.writeJson(
      versionPath,
      {
        version: '1.0.0',
        remotes: [
          {
            transportType: 'streamable-http',
            url: 'https://example.com/mcp',
          },
        ],
      },
      { spaces: 2 },
    );

    let thrownError;
    try {
      await runRegistryGeneration({
        workspaceRoot,
        actionType: 'validate_registry',
        sourceDir: './servers',
        outputDir: './dist',
        deploymentEnvironment: 'github',
        schemasDir: path.join(workspaceRoot, 'schemas'),
      });
    } catch (error) {
      thrownError = error;
    }

    expect(thrownError).to.be.instanceOf(Error);
    expect(thrownError.message).to.equal('No valid servers found');
  });

  it('logs every generated file when log level is debug', async () => {
    const debugMessages = [];
    const logger = {
      level: 'debug',
      debug: (...args) => {
        debugMessages.push(args.join(' '));
      },
      info: () => {},
      warn: () => {},
      error: () => {},
    };

    await runRegistryGeneration({
      logger,
      workspaceRoot,
      sourceDir: './servers',
      outputDir: './dist',
      deploymentEnvironment: 'github',
      schemasDir: path.join(workspaceRoot, 'schemas'),
    });

    const outputRoot = resolveOutputPath(workspaceRoot);
    const generatedFiles = await listFilesRecursively(outputRoot);
    const expectedRelativePaths = new Set(
      generatedFiles.map((filePath) => path.relative(workspaceRoot, filePath)),
    );
    const loggedRelativePaths = new Set(
      debugMessages
        .filter((message) => message.startsWith('✓ Generated file: '))
        .map((message) => message.replace('✓ Generated file: ', '')),
    );

    expect(loggedRelativePaths.size).to.equal(expectedRelativePaths.size);
    for (const filePath of expectedRelativePaths) {
      expect(loggedRelativePaths.has(filePath)).to.equal(true);
    }
  });
});
